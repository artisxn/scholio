'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Default event namespace.
 */
var defaultNamespace = {
    value: 'App.Events'
};

var EchoEventFormatter = function () {
    function EchoEventFormatter() {
        _classCallCheck(this, EchoEventFormatter);
    }

    _createClass(EchoEventFormatter, null, [{
        key: 'format',

        /**
         * Format the given event name.
         */
        value: function format(event) {
            if (event.charAt(0) != '\\') {
                event = defaultNamespace.value + '.' + event;
            }

            return event.replace(/\./g, '\\');
        }
    }]);

    return EchoEventFormatter;
}();

var PusherConnector = function () {
    function PusherConnector() {
        _classCallCheck(this, PusherConnector);
    }

    _createClass(PusherConnector, null, [{
        key: 'connect',

        /**
         * Create a fresh Pusher connection.
         */
        value: function connect(pusherKey) {
            var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

            var csrfToken = _ref.csrfToken;

            var customOptions = _objectWithoutProperties(_ref, ['csrfToken']);

            var csrfToken = csrfToken || PusherConnector.csrfToken();

            var pusher = new Pusher(pusherKey, PusherConnector.options(csrfToken, customOptions));

            pusher.connection.bind('connected', function () {
                var request = new XMLHttpRequest();
                request.open('POST', '/broadcasting/socket', true);
                request.setRequestHeader('Content-Type', 'application/json');
                request.setRequestHeader('X-CSRF-Token', csrfToken);
                request.send(JSON.stringify({
                    "socket_id": pusher.connection.socket_id
                }));
            });

            return pusher;
        }

        /**
         * Merge the custom Pusher options with the defaults.
         */

    }, {
        key: 'options',
        value: function options(csrfToken, customOptions) {
            var options = {
                authEndpoint: '/broadcasting/auth',
                auth: {
                    headers: { 'X-CSRF-Token': csrfToken }
                }
            };

            return _extends(options, customOptions);
        }

        /**
         * Extract the CSRF token from the page.
         */

    }, {
        key: 'csrfToken',
        value: function csrfToken() {
            var selector = document.querySelector('meta[name="csrf-token"]');

            if (!selector) {
                console.error('Unable to locate CSRF token on page.');
            } else {
                return selector.getAttribute('content');
            }
        }
    }]);

    return PusherConnector;
}();

/**
 * This class represents a basic Pusher channel.
 */


var EchoChannel = function () {
    /**
     * Create a new class instance.
     */

    function EchoChannel(channel) {
        _classCallCheck(this, EchoChannel);

        this.channel = channel;
    }

    /**
     * Listen for an event on the channel instance.
     */


    _createClass(EchoChannel, [{
        key: 'listen',
        value: function listen(event, callback) {
            this.channel.bind(EchoEventFormatter.format(event), callback);

            return this;
        }
    }]);

    return EchoChannel;
}();

/**
 * This class represents a Pusher presence channel.
 */


var EchoPresenceChannel = function () {
    /**
     * Create a new class instance.
     */

    function EchoPresenceChannel(channel) {
        _classCallCheck(this, EchoPresenceChannel);

        this.channel = channel;
    }

    /**
     * Register a callback to be called anytime the member list changes.
     */


    _createClass(EchoPresenceChannel, [{
        key: 'here',
        value: function here(callback) {
            var _this = this;

            this.then(callback);

            var addedOrRemovedCallback = function addedOrRemovedCallback(member) {
                var members = Object.keys(_this.channel.members.members).map(function (k) {
                    return _this.channel.members.members[k];
                });

                callback(members, _this.channel);
            };

            this.channel.bind('pusher:member_added', addedOrRemovedCallback);
            this.channel.bind('pusher:member_removed', addedOrRemovedCallback);

            return this;
        }

        /**
         * Register a callback to be called on successfully joining the channel.
         */

    }, {
        key: 'then',
        value: function then(callback) {
            var _this2 = this;

            this.channel.bind('pusher:subscription_succeeded', function (message) {
                var members = Object.keys(message.members).map(function (k) {
                    return message.members[k];
                });

                callback(members, _this2.channel);
            });

            return this;
        }

        /**
         * Listen for someone joining the channel.
         */

    }, {
        key: 'joining',
        value: function joining(callback) {
            var _this3 = this;

            this.channel.bind('pusher:member_added', function (member) {
                var members = Object.keys(_this3.channel.members.members).map(function (k) {
                    return _this3.channel.members.members[k];
                });

                callback(member.info, members, _this3.channel);
            });

            return this;
        }

        /**
         * Listen for someone leaving the channel.
         */

    }, {
        key: 'leaving',
        value: function leaving(callback) {
            var _this4 = this;

            this.channel.bind('pusher:member_removed', function (member) {
                var members = Object.keys(_this4.channel.members.members).map(function (k) {
                    return _this4.channel.members.members[k];
                });

                callback(member.info, members, _this4.channel);
            });

            return this;
        }

        /**
         * Listen for an event on the channel instance.
         */

    }, {
        key: 'listen',
        value: function listen(event, callback) {
            var _this5 = this;

            this.channel.bind(EchoEventFormatter.format(event), function (data) {
                callback(data, _this5.channel);
            });

            return this;
        }
    }]);

    return EchoPresenceChannel;
}();

/**
 * This class is the primary API for interacting with Pusher.
 */


var Echo = function () {
    /**
     * Create a new class instance.
     */

    function Echo(pusherKey) {
        var customOptions = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

        _classCallCheck(this, Echo);

        this.channels = [];

        this.pusher = PusherConnector.connect(pusherKey, customOptions);
    }

    /**
     * Listen for an event on a channel instance.
     */


    _createClass(Echo, [{
        key: 'listen',
        value: function listen(channel, event, callback) {
            return this.channel(channel).listen(event, callback);
        }

        /**
         * Get a channel instance by name.
         */

    }, {
        key: 'channel',
        value: function channel(_channel) {
            return new EchoChannel(this.createChannel(_channel));
        }

        /**
         * Get a private channel instance by name.
         */

    }, {
        key: 'private',
        value: function _private(channel) {
            return this.channel('private-' + channel);
        }

        /**
         * Get a presence channel instance by name.
         */

    }, {
        key: 'join',
        value: function join(channel) {
            return new EchoPresenceChannel(this.createChannel('presence-' + channel));
        }

        /**
         * Create an subscribe to a fresh channel instance.
         */

    }, {
        key: 'createChannel',
        value: function createChannel(channel) {
            if (!this.channels[channel]) {
                this.channels[channel] = this.pusher.subscribe(channel);
            }

            return this.channels[channel];
        }

        /**
         * Leave the given channel.
         */

    }, {
        key: 'leave',
        value: function leave(channel) {
            var _this6 = this;

            var channels = [channel, 'private-' + channel, 'presence-' + channel];

            channels.forEach(function (channelName) {
                if (_this6.channels[channelName]) {
                    _this6.pusher.unsubscribe(channelName);

                    _this6.channels.splice(channelName, 1);
                }
            });
        }

        /**
         * Get the Socket ID for the connection.
         */

    }, {
        key: 'socketId',
        value: function socketId() {
            return this.pusher.connection.socket_id;
        }

        /**
         * Set the default event namespace.
         */

    }, {
        key: 'namespace',
        value: function namespace(value) {
            defaultNamespace.value = value;
        }
    }]);

    return Echo;
}();

exports.default = Echo;